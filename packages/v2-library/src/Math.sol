//SPDX-License-Identifier: Unlicense
pragma solidity =0.8.8;

library Math {
    /// @dev Reverts when divide by zero.
    error DivideByZero();
    error Overflow();

    /// @dev Add two uint256.
    /// @notice May overflow.
    /// @param addend1 The first addend.
    /// @param addend2 The second addend.
    /// @return sum The sum.
    function unsafeAdd(uint256 addend1, uint256 addend2) internal pure returns (uint256 sum) {
        unchecked {
            sum = addend1 + addend2;
        }
    }

    /// @dev Subtract two uint256.
    /// @notice May underflow.
    /// @param minuend The minuend.
    /// @param subtrahend The subtrahend.
    /// @return difference The difference.
    function unsafeSub(uint256 minuend, uint256 subtrahend) internal pure returns (uint256 difference) {
        unchecked {
            difference = minuend - subtrahend;
        }
    }

    /// @dev Multiply two uint256.
    /// @notice May overflow.
    /// @param multiplicand The multiplicand.
    /// @param multiplier The multiplier.
    /// @return product The product.
    function unsafeMul(uint256 multiplicand, uint256 multiplier) internal pure returns (uint256 product) {
        unchecked {
            product = multiplicand * multiplier;
        }
    }

    /// @dev Divide two uint256.
    /// @notice Reverts when divide by zero.
    /// @param dividend The dividend.
    /// @param divisor The divisor.
    //// @param roundUp Round up the result when true. Round down if false.
    /// @return quotient The quotient.
    function div(uint256 dividend, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient) {
        quotient = dividend / divisor;

        if (roundUp && dividend % divisor != 0) quotient++;
    }

    /// @dev Shift right a uint256 number.
    /// @param dividend The dividend.
    /// @param divisorBit The divisor in bits.
    /// @param roundUp True if ceiling the result. False if floor the result.
    /// @return quotient The quotient.
    function shr(uint256 dividend, uint8 divisorBit, bool roundUp) internal pure returns (uint256 quotient) {
        quotient = dividend >> divisorBit;

        if (roundUp && dividend % (1 << divisorBit) != 0) quotient++;
    }

    /// @dev Gets the square root of a value.
    /// @param value The value being square rooted.
    /// @param roundUp Round up the result when true. Round down if false.
    /// @return result The resulting value of the square root.
    function sqrt(uint256 value, bool roundUp) internal pure returns (uint256 result) {
        if (value == type(uint256).max) return result = type(uint128).max;
        if (value == 0) return 0;
        unchecked {
            uint256 estimate = (value + 1) >> 1;
            result = value;
            while (estimate < result) {
                result = estimate;
                estimate = (value / estimate + estimate) >> 1;
            }
        }

        if (roundUp && value % result != 0) result++;
    }

    /// @dev Gets the min of two uint256 number.
    /// @param value1 The first value to be compared.
    /// @param value2 The second value to be compared.
    /// @return result The min result.
    function min(uint256 value1, uint256 value2) internal pure returns (uint256 result) {
        return value1 < value2 ? value1 : value2;
    }
}
